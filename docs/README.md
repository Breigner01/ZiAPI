# ZiAPI Documentation üìö

Welcome to the main documentation page of the ZiAPI. The ZiAPI is a set of interfaces and concrete implementations to help you manage module implementation for the Zia project.

## Introduction üëÄ

ZiAPI aims at making your life easier as a developper. It features different type of modules that you can implement to customize parts of your Zia project.

Here is an overview of what you can do using the ZiAPI module interfaces:
- Switch between HTTP versions 1.0, 1.1, 2 and 3
- Change the underlying network implementation (UDP, TCP, Quic, ...)
- Change the behaviour of your HTTP server (Directory Listing, PHP CGI)
- Manage multiple sites and conditional module execution (e.g. only execute a module on a request if it is a `GET` request)

## Architecture üè¶

To understand how the ZiAPI works, lets take a look at how requests are handled from start to finish.

#### Step 1. Network

The request is first handled through the network layer which is a module in itself. This is where you'll setup your sockets and listeners, your hypothetical SSL / TLS encryption logic, your HTTP parser and any additional serialization / deserialization code. When a request arrives, the networking layer must read it, decrypt it, parse it and forward it to the next layer: the pre-processing layer!

#### Step 2. Pre-processing

Once the request lands in the pre-processing layer a pipeline of request pre-processing modules will be invoked. This is where you shall route the request, log it, rewrite its URL, add / remove some headers, etc.

#### Step 3. Handling

Once the whole pre-processing pipeline has been applied on the request, the corresponding handler for this request is invoked. A handler will generate the HTTP response for a request. So that might be the contents of a file (Directory Listing module), the output of a PHP script (PHP CGI) or some JSON output gathered from a database, you choose!

#### Step 4. Post-processing

Once the HTTP response has been generated by the handling layer, it is forwarded to the post-processing layer. This is where a pipeline of response post-processing modules will be invoked. This is where you can serialize the contents of your response body, log the response, add additional headers such as CORS, etc.

#### Step 5. More networking

Once the post-processing pipeline has been applied on the response, it is forwarded back to the network layer to be sent back over the network. This is where you will serialize your HTTP message, and possibly encode it using TLS before writing it to your socket.

And boom! Request handled!

## Modules üíæ

Let's see how all these different steps translate into modules!

As we saw earlier, the ZiAPI features multiple **module types**.
- `INetworkModule`
- `IPreProcessingModule`
- `IHandlerModule`
- `IPostProcessingModule`

Let's take a look at each of them but first let's check the `IModule` interface.

#### `IModule`

Each ZiAPI module type inherits from `IModule`. It features very basic methods to make it easier to manage modules.

```c++
void IModule::Init(const IConfig &cfg);

Version IModule::GetVersion() const;

Version IModule::GetCompatibleApiVersion() const;

const char *IModule::GetName() const;

const char *IModule::GetDescription() const;
```

#### `INetworkModule`

#### `IPreProcessingModule`

#### `IHandlerModule`

#### `IPostProcessingModule`
